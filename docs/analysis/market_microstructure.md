# Market Microstructure y Tape Reading

## Fundamentos de Market Microstructure

### ComprensiÃ³n del Order Book
```python
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple
import asyncio
from collections import deque

@dataclass
class OrderBookLevel:
    """Nivel del order book"""
    price: float
    size: int
    orders: int = 1

@dataclass
class OrderBook:
    """Order book completo"""
    symbol: str
    timestamp: datetime
    bids: List[OrderBookLevel]
    asks: List[OrderBookLevel]
    
    def get_spread(self) -> float:
        """Obtener spread bid-ask"""
        if not self.bids or not self.asks:
            return 0.0
        return self.asks[0].price - self.bids[0].price
    
    def get_mid_price(self) -> float:
        """Obtener precio medio"""
        if not self.bids or not self.asks:
            return 0.0
        return (self.bids[0].price + self.asks[0].price) / 2
    
    def get_total_bid_volume(self, levels: int = 5) -> int:
        """Volumen total en bids"""
        return sum(level.size for level in self.bids[:levels])
    
    def get_total_ask_volume(self, levels: int = 5) -> int:
        """Volumen total en asks"""
        return sum(level.size for level in self.asks[:levels])
    
    def get_imbalance_ratio(self, levels: int = 5) -> float:
        """Ratio de imbalance bid/ask"""
        bid_vol = self.get_total_bid_volume(levels)
        ask_vol = self.get_total_ask_volume(levels)
        
        if ask_vol == 0:
            return float('inf') if bid_vol > 0 else 1.0
        
        return bid_vol / ask_vol
    
    def get_depth_at_price(self, price: float, side: str) -> int:
        """Obtener profundidad a precio especÃ­fico"""
        levels = self.bids if side == 'bid' else self.asks
        
        for level in levels:
            if (side == 'bid' and level.price <= price) or \
               (side == 'ask' and level.price >= price):
                return level.size
        
        return 0

class MarketMicrostructureAnalyzer:
    """Analizador de microestructura de mercado"""
    
    def __init__(self, max_history: int = 1000):
        self.order_books: deque = deque(maxlen=max_history)
        self.trades: deque = deque(maxlen=max_history)
        self.metrics_history: List[Dict] = []
    
    def add_order_book(self, order_book: OrderBook):
        """Agregar nuevo order book"""
        self.order_books.append(order_book)
        
        # Calcular mÃ©tricas si tenemos suficiente historia
        if len(self.order_books) >= 2:
            metrics = self._calculate_microstructure_metrics(order_book)
            self.metrics_history.append(metrics)
    
    def add_trade(self, trade: Dict):
        """Agregar nuevo trade"""
        self.trades.append(trade)
    
    def _calculate_microstructure_metrics(self, current_book: OrderBook) -> Dict:
        """Calcular mÃ©tricas de microestructura"""
        
        metrics = {
            'timestamp': current_book.timestamp,
            'symbol': current_book.symbol,
            'mid_price': current_book.get_mid_price(),
            'spread': current_book.get_spread(),
            'spread_bps': 0,
            'imbalance_ratio': current_book.get_imbalance_ratio(),
            'bid_depth': current_book.get_total_bid_volume(),
            'ask_depth': current_book.get_total_ask_volume(),
            'total_depth': current_book.get_total_bid_volume() + current_book.get_total_ask_volume()
        }
        
        # Spread en basis points
        if metrics['mid_price'] > 0:
            metrics['spread_bps'] = (metrics['spread'] / metrics['mid_price']) * 10000
        
        # MÃ©tricas comparativas si tenemos historia
        if len(self.order_books) >= 2:
            prev_book = self.order_books[-2]
            
            # Cambio en mid price
            prev_mid = prev_book.get_mid_price()
            if prev_mid > 0:
                metrics['mid_price_change'] = (metrics['mid_price'] - prev_mid) / prev_mid
            else:
                metrics['mid_price_change'] = 0.0
            
            # Cambio en spread
            prev_spread = prev_book.get_spread()
            metrics['spread_change'] = metrics['spread'] - prev_spread
            
            # Cambio en imbalance
            prev_imbalance = prev_book.get_imbalance_ratio()
            metrics['imbalance_change'] = metrics['imbalance_ratio'] - prev_imbalance
        
        # MÃ©tricas de volatilidad si tenemos suficiente historia
        if len(self.metrics_history) >= 20:
            recent_mid_prices = [m['mid_price'] for m in self.metrics_history[-20:]]
            recent_spreads = [m['spread'] for m in self.metrics_history[-20:]]
            
            metrics['mid_price_volatility'] = np.std(recent_mid_prices)
            metrics['spread_volatility'] = np.std(recent_spreads)
        
        return metrics
    
    def detect_order_flow_patterns(self) -> Dict:
        """Detectar patrones en el order flow"""
        
        if len(self.metrics_history) < 10:
            return {}
        
        patterns = {}
        recent_metrics = self.metrics_history[-10:]
        
        # 1. Spread widening pattern
        recent_spreads = [m['spread'] for m in recent_metrics]
        spread_trend = np.polyfit(range(len(recent_spreads)), recent_spreads, 1)[0]
        patterns['spread_widening'] = spread_trend > 0.001
        
        # 2. Imbalance persistence
        recent_imbalances = [m['imbalance_ratio'] for m in recent_metrics]
        avg_imbalance = np.mean(recent_imbalances)
        patterns['persistent_bid_imbalance'] = avg_imbalance > 1.5
        patterns['persistent_ask_imbalance'] = avg_imbalance < 0.67
        
        # 3. Depth depletion
        recent_depths = [m['total_depth'] for m in recent_metrics]
        depth_trend = np.polyfit(range(len(recent_depths)), recent_depths, 1)[0]
        patterns['depth_depletion'] = depth_trend < -100
        
        # 4. Price instability
        recent_vol = [m.get('mid_price_volatility', 0) for m in recent_metrics[-5:]]
        avg_volatility = np.mean([v for v in recent_vol if v > 0])
        patterns['high_volatility'] = avg_volatility > 0.001
        
        return patterns
    
    def calculate_market_impact(self, order_size: int, side: str) -> float:
        """Calcular impacto de mercado estimado"""
        
        if not self.order_books:
            return 0.0
        
        current_book = self.order_books[-1]
        levels = current_book.asks if side == 'buy' else current_book.bids
        
        remaining_size = order_size
        total_cost = 0.0
        reference_price = current_book.get_mid_price()
        
        for level in levels:
            if remaining_size <= 0:
                break
            
            filled_size = min(remaining_size, level.size)
            total_cost += filled_size * level.price
            remaining_size -= filled_size
        
        if remaining_size > 0:
            # Si no hay suficiente liquidez, estimar impacto adicional
            last_price = levels[-1].price if levels else reference_price
            additional_impact = remaining_size * 0.01  # 1% adicional por cada share sin liquidez
            total_cost += remaining_size * (last_price + additional_impact)
        
        # Calcular impacto como % del precio de referencia
        avg_execution_price = total_cost / order_size
        impact = abs(avg_execution_price - reference_price) / reference_price
        
        return impact

# Demo del analizador de microestructura
def demo_microstructure_analyzer():
    """Demo del anÃ¡lisis de microestructura"""
    
    analyzer = MarketMicrostructureAnalyzer()
    
    # Simular order books
    for i in range(20):
        # Generar order book sintÃ©tico
        base_price = 100 + np.random.normal(0, 0.1)
        spread = 0.01 + np.random.exponential(0.005)
        
        # Bids (prices descendentes)
        bids = []
        for j in range(10):
            price = base_price - spread/2 - j*0.01
            size = np.random.randint(100, 1000)
            bids.append(OrderBookLevel(price, size))
        
        # Asks (prices ascendentes) 
        asks = []
        for j in range(10):
            price = base_price + spread/2 + j*0.01
            size = np.random.randint(100, 1000)
            asks.append(OrderBookLevel(price, size))
        
        order_book = OrderBook(
            symbol="AAPL",
            timestamp=datetime.now() + timedelta(seconds=i),
            bids=bids,
            asks=asks
        )
        
        analyzer.add_order_book(order_book)
    
    # Analizar patrones
    patterns = analyzer.detect_order_flow_patterns()
    print("ðŸ“Š AnÃ¡lisis de Microestructura:")
    print(f"Spread widening: {patterns.get('spread_widening', False)}")
    print(f"Bid imbalance: {patterns.get('persistent_bid_imbalance', False)}")
    print(f"Ask imbalance: {patterns.get('persistent_ask_imbalance', False)}")
    print(f"Depth depletion: {patterns.get('depth_depletion', False)}")
    
    # Calcular impacto de mercado
    impact_buy_1000 = analyzer.calculate_market_impact(1000, 'buy')
    impact_sell_1000 = analyzer.calculate_market_impact(1000, 'sell')
    
    print(f"\nðŸ’° Impacto de Mercado:")
    print(f"Buy 1000 shares: {impact_buy_1000:.4%}")
    print(f"Sell 1000 shares: {impact_sell_1000:.4%}")

if __name__ == "__main__":
    demo_microstructure_analyzer()
```

## Tape Reading Moderno

### Sistema de AnÃ¡lisis de Time & Sales
```python
from enum import Enum
from collections import Counter

class TradeType(Enum):
    """Tipos de trade"""
    BUY_MARKET = "buy_market"      # Market buy (hit ask)
    SELL_MARKET = "sell_market"    # Market sell (hit bid)
    BUY_LIMIT = "buy_limit"        # Limit buy
    SELL_LIMIT = "sell_limit"      # Limit sell
    UNKNOWN = "unknown"

@dataclass
class Trade:
    """Trade individual"""
    symbol: str
    timestamp: datetime
    price: float
    size: int
    trade_type: TradeType
    aggressor_side: str  # 'buy', 'sell', 'unknown'
    
    def get_dollar_volume(self) -> float:
        """Obtener volumen en dÃ³lares"""
        return self.price * self.size

class TapeReader:
    """Sistema de tape reading moderno"""
    
    def __init__(self, lookback_minutes: int = 30):
        self.lookback_minutes = lookback_minutes
        self.trades: deque = deque(maxlen=10000)
        self.order_books: deque = deque(maxlen=1000)
        
        # MÃ©tricas de seguimiento
        self.volume_profile = {}
        self.size_profile = Counter()
        self.time_profile = {}
    
    def add_trade(self, trade: Trade):
        """Agregar nuevo trade"""
        self.trades.append(trade)
        self._update_profiles(trade)
    
    def _update_profiles(self, trade: Trade):
        """Actualizar perfiles de trading"""
        
        # Volume profile por precio
        price_bucket = round(trade.price, 2)
        if price_bucket not in self.volume_profile:
            self.volume_profile[price_bucket] = {'volume': 0, 'trades': 0}
        
        self.volume_profile[price_bucket]['volume'] += trade.size
        self.volume_profile[price_bucket]['trades'] += 1
        
        # Size profile
        size_bucket = self._get_size_bucket(trade.size)
        self.size_profile[size_bucket] += 1
        
        # Time profile
        minute_bucket = trade.timestamp.replace(second=0, microsecond=0)
        if minute_bucket not in self.time_profile:
            self.time_profile[minute_bucket] = {'volume': 0, 'trades': 0}
        
        self.time_profile[minute_bucket]['volume'] += trade.size
        self.time_profile[minute_bucket]['trades'] += 1
    
    def _get_size_bucket(self, size: int) -> str:
        """Obtener bucket de tamaÃ±o"""
        if size < 100:
            return "small"
        elif size < 500:
            return "medium"
        elif size < 1000:
            return "large"
        elif size < 5000:
            return "block"
        else:
            return "institutional"
    
    def get_recent_trades(self, minutes: int = 5) -> List[Trade]:
        """Obtener trades recientes"""
        cutoff_time = datetime.now() - timedelta(minutes=minutes)
        return [trade for trade in self.trades if trade.timestamp >= cutoff_time]
    
    def analyze_order_flow(self, minutes: int = 5) -> Dict:
        """Analizar order flow reciente"""
        
        recent_trades = self.get_recent_trades(minutes)
        
        if not recent_trades:
            return {}
        
        # MÃ©tricas bÃ¡sicas
        total_volume = sum(trade.size for trade in recent_trades)
        total_dollar_volume = sum(trade.get_dollar_volume() for trade in recent_trades)
        
        # Separar por lado
        buy_trades = [t for t in recent_trades if t.aggressor_side == 'buy']
        sell_trades = [t for t in recent_trades if t.aggressor_side == 'sell']
        
        buy_volume = sum(trade.size for trade in buy_trades)
        sell_volume = sum(trade.size for trade in sell_trades)
        
        # Ratio de volumen
        buy_sell_ratio = buy_volume / sell_volume if sell_volume > 0 else float('inf')
        
        # TamaÃ±o promedio de trades
        avg_trade_size = total_volume / len(recent_trades)
        
        # Trades grandes (>1000 shares)
        large_trades = [t for t in recent_trades if t.size >= 1000]
        large_trade_volume = sum(t.size for t in large_trades)
        large_trade_pct = large_trade_volume / total_volume if total_volume > 0 else 0
        
        # Velocidad de trading
        time_span = (recent_trades[-1].timestamp - recent_trades[0].timestamp).total_seconds() / 60
        trades_per_minute = len(recent_trades) / time_span if time_span > 0 else 0
        
        return {
            'period_minutes': minutes,
            'total_trades': len(recent_trades),
            'total_volume': total_volume,
            'total_dollar_volume': total_dollar_volume,
            'buy_volume': buy_volume,
            'sell_volume': sell_volume,
            'buy_sell_ratio': buy_sell_ratio,
            'avg_trade_size': avg_trade_size,
            'large_trades_count': len(large_trades),
            'large_trade_volume_pct': large_trade_pct,
            'trades_per_minute': trades_per_minute
        }
    
    def detect_tape_patterns(self) -> Dict:
        """Detectar patrones en el tape"""
        
        patterns = {}
        recent_trades = self.get_recent_trades(10)  # Ãšltimos 10 minutos
        
        if len(recent_trades) < 10:
            return patterns
        
        # 1. Accumulation/Distribution pattern
        buy_volume = sum(t.size for t in recent_trades if t.aggressor_side == 'buy')
        sell_volume = sum(t.size for t in recent_trades if t.aggressor_side == 'sell')
        
        if buy_volume > sell_volume * 1.5:
            patterns['accumulation'] = True
        elif sell_volume > buy_volume * 1.5:
            patterns['distribution'] = True
        
        # 2. Size clustering
        large_trades = [t for t in recent_trades if t.size >= 1000]
        if len(large_trades) >= 3:
            patterns['institutional_activity'] = True
        
        # 3. Rapid fire pattern (muchos trades pequeÃ±os seguidos)
        small_trades = [t for t in recent_trades if t.size <= 100]
        if len(small_trades) >= len(recent_trades) * 0.7:
            patterns['rapid_fire'] = True
        
        # 4. Price level testing
        prices = [t.price for t in recent_trades]
        price_variance = np.var(prices)
        
        if price_variance < 0.01:  # Precio muy estable
            patterns['price_level_test'] = True
        
        # 5. Momentum pattern
        if len(recent_trades) >= 5:
            # Calcular si precio estÃ¡ subiendo/bajando consistentemente
            price_changes = []
            for i in range(1, len(recent_trades)):
                change = recent_trades[i].price - recent_trades[i-1].price
                price_changes.append(change)
            
            positive_changes = sum(1 for c in price_changes if c > 0)
            negative_changes = sum(1 for c in price_changes if c < 0)
            
            if positive_changes >= len(price_changes) * 0.8:
                patterns['upward_momentum'] = True
            elif negative_changes >= len(price_changes) * 0.8:
                patterns['downward_momentum'] = True
        
        # 6. Iceberg detection (trades consistentes del mismo tamaÃ±o)
        trade_sizes = [t.size for t in recent_trades]
        size_counts = Counter(trade_sizes)
        max_repeated_size = max(size_counts.values()) if size_counts else 0
        
        if max_repeated_size >= 5:  # Mismo tamaÃ±o repetido 5+ veces
            patterns['potential_iceberg'] = True
        
        return patterns
    
    def get_support_resistance_levels(self) -> Dict:
        """Obtener niveles de soporte/resistencia basados en volume profile"""
        
        if not self.volume_profile:
            return {}
        
        # Ordenar por volumen
        sorted_levels = sorted(self.volume_profile.items(), 
                             key=lambda x: x[1]['volume'], reverse=True)
        
        # Top 5 niveles por volumen
        high_volume_levels = sorted_levels[:5]
        
        # Identificar precio actual
        recent_trades = self.get_recent_trades(1)
        current_price = recent_trades[-1].price if recent_trades else 0
        
        # Separar en soporte y resistencia
        support_levels = []
        resistance_levels = []
        
        for price, data in high_volume_levels:
            if price < current_price:
                support_levels.append({
                    'price': price,
                    'volume': data['volume'],
                    'trades': data['trades']
                })
            else:
                resistance_levels.append({
                    'price': price,
                    'volume': data['volume'],
                    'trades': data['trades']
                })
        
        # Ordenar soporte descendente, resistencia ascendente
        support_levels.sort(key=lambda x: x['price'], reverse=True)
        resistance_levels.sort(key=lambda x: x['price'])
        
        return {
            'current_price': current_price,
            'support_levels': support_levels[:3],
            'resistance_levels': resistance_levels[:3]
        }
    
    def calculate_buying_selling_pressure(self, minutes: int = 15) -> Dict:
        """Calcular presiÃ³n compradora/vendedora"""
        
        recent_trades = self.get_recent_trades(minutes)
        
        if not recent_trades:
            return {}
        
        # Separar por tipo de trade
        market_buys = [t for t in recent_trades if t.trade_type == TradeType.BUY_MARKET]
        market_sells = [t for t in recent_trades if t.trade_type == TradeType.SELL_MARKET]
        
        # Volumen por tipo
        market_buy_volume = sum(t.size for t in market_buys)
        market_sell_volume = sum(t.size for t in market_sells)
        
        # Dollar volume por tipo
        market_buy_dollars = sum(t.get_dollar_volume() for t in market_buys)
        market_sell_dollars = sum(t.get_dollar_volume() for t in market_sells)
        
        # PresiÃ³n neta
        volume_pressure = market_buy_volume - market_sell_volume
        dollar_pressure = market_buy_dollars - market_sell_dollars
        
        # Ratios
        total_market_volume = market_buy_volume + market_sell_volume
        buy_pressure_ratio = market_buy_volume / total_market_volume if total_market_volume > 0 else 0.5
        
        return {
            'market_buy_volume': market_buy_volume,
            'market_sell_volume': market_sell_volume,
            'market_buy_dollars': market_buy_dollars,
            'market_sell_dollars': market_sell_dollars,
            'net_volume_pressure': volume_pressure,
            'net_dollar_pressure': dollar_pressure,
            'buy_pressure_ratio': buy_pressure_ratio,
            'sell_pressure_ratio': 1 - buy_pressure_ratio
        }

# Sistema de alertas basado en tape reading
class TapeAlertSystem:
    """Sistema de alertas basado en anÃ¡lisis de tape"""
    
    def __init__(self, tape_reader: TapeReader):
        self.tape_reader = tape_reader
        self.alert_thresholds = {
            'large_trade_size': 5000,
            'rapid_fire_count': 10,
            'buy_sell_imbalance': 2.0,
            'institutional_volume_pct': 0.3
        }
    
    def check_alerts(self) -> List[Dict]:
        """Verificar condiciones de alerta"""
        
        alerts = []
        
        # Analizar order flow reciente
        flow_analysis = self.tape_reader.analyze_order_flow(5)
        
        if not flow_analysis:
            return alerts
        
        # 1. Large trade alert
        if flow_analysis.get('large_trades_count', 0) >= 3:
            alerts.append({
                'type': 'large_trades',
                'message': f"MÃºltiples trades grandes detectados: {flow_analysis['large_trades_count']}",
                'severity': 'medium',
                'data': flow_analysis
            })
        
        # 2. Buy/Sell imbalance alert
        buy_sell_ratio = flow_analysis.get('buy_sell_ratio', 1.0)
        if buy_sell_ratio > self.alert_thresholds['buy_sell_imbalance']:
            alerts.append({
                'type': 'buy_imbalance',
                'message': f"Fuerte presiÃ³n compradora detectada: ratio {buy_sell_ratio:.1f}",
                'severity': 'high',
                'data': flow_analysis
            })
        elif buy_sell_ratio < 1 / self.alert_thresholds['buy_sell_imbalance']:
            alerts.append({
                'type': 'sell_imbalance',
                'message': f"Fuerte presiÃ³n vendedora detectada: ratio {buy_sell_ratio:.1f}",
                'severity': 'high',
                'data': flow_analysis
            })
        
        # 3. Institutional volume alert
        large_trade_pct = flow_analysis.get('large_trade_volume_pct', 0)
        if large_trade_pct > self.alert_thresholds['institutional_volume_pct']:
            alerts.append({
                'type': 'institutional_volume',
                'message': f"Alto volumen institucional: {large_trade_pct:.1%}",
                'severity': 'high',
                'data': flow_analysis
            })
        
        # 4. Pattern alerts
        patterns = self.tape_reader.detect_tape_patterns()
        
        for pattern, detected in patterns.items():
            if detected:
                alerts.append({
                    'type': 'pattern',
                    'message': f"PatrÃ³n detectado: {pattern}",
                    'severity': 'medium',
                    'data': {'pattern': pattern, 'flow_analysis': flow_analysis}
                })
        
        return alerts

# Demo del sistema de tape reading
def demo_tape_reading():
    """Demo del sistema de tape reading"""
    
    tape_reader = TapeReader()
    alert_system = TapeAlertSystem(tape_reader)
    
    # Simular trades
    base_price = 150.0
    current_time = datetime.now()
    
    for i in range(100):
        # Simular diferentes tipos de trades
        if i < 20:
            # PerÃ­odo de acumulaciÃ³n
            trade_type = TradeType.BUY_MARKET
            aggressor = 'buy'
            size = np.random.choice([100, 200, 500], p=[0.6, 0.3, 0.1])
        elif i < 40:
            # Trades normales
            trade_type = np.random.choice([TradeType.BUY_MARKET, TradeType.SELL_MARKET])
            aggressor = 'buy' if trade_type == TradeType.BUY_MARKET else 'sell'
            size = np.random.randint(100, 300)
        elif i < 60:
            # PerÃ­odo con trades grandes
            trade_type = np.random.choice([TradeType.BUY_MARKET, TradeType.SELL_MARKET])
            aggressor = 'buy' if trade_type == TradeType.BUY_MARKET else 'sell'
            size = np.random.choice([1000, 2000, 5000], p=[0.7, 0.2, 0.1])
        else:
            # DistribuciÃ³n
            trade_type = TradeType.SELL_MARKET
            aggressor = 'sell'
            size = np.random.choice([200, 500, 1000], p=[0.5, 0.3, 0.2])
        
        # Precio con drift aleatorio
        price_change = np.random.normal(0, 0.01)
        base_price += price_change
        
        trade = Trade(
            symbol="AAPL",
            timestamp=current_time + timedelta(seconds=i*30),
            price=round(base_price, 2),
            size=size,
            trade_type=trade_type,
            aggressor_side=aggressor
        )
        
        tape_reader.add_trade(trade)
    
    # Analizar resultados
    flow_analysis = tape_reader.analyze_order_flow(10)
    patterns = tape_reader.detect_tape_patterns()
    pressure = tape_reader.calculate_buying_selling_pressure()
    support_resistance = tape_reader.get_support_resistance_levels()
    alerts = alert_system.check_alerts()
    
    print("ðŸ“Š AnÃ¡lisis de Tape Reading:")
    print(f"Total trades: {flow_analysis.get('total_trades', 0)}")
    print(f"Buy/Sell ratio: {flow_analysis.get('buy_sell_ratio', 0):.2f}")
    print(f"Large trades: {flow_analysis.get('large_trades_count', 0)} ({flow_analysis.get('large_trade_volume_pct', 0):.1%})")
    
    print(f"\nðŸŽ¯ Patrones detectados:")
    for pattern, detected in patterns.items():
        if detected:
            print(f"  âœ… {pattern}")
    
    print(f"\nðŸ’ª PresiÃ³n de mercado:")
    print(f"PresiÃ³n compradora: {pressure.get('buy_pressure_ratio', 0):.1%}")
    print(f"PresiÃ³n vendedora: {pressure.get('sell_pressure_ratio', 0):.1%}")
    
    print(f"\nðŸš¨ Alertas: {len(alerts)}")
    for alert in alerts:
        print(f"  {alert['type']}: {alert['message']}")

if __name__ == "__main__":
    demo_tape_reading()
```

## IntegraciÃ³n con Estrategias de Trading

### SeÃ±ales Basadas en Microestructura
```python
class MicrostructureSignalGenerator:
    """Generador de seÃ±ales basado en microestructura"""
    
    def __init__(self, tape_reader: TapeReader, microstructure_analyzer: MarketMicrostructureAnalyzer):
        self.tape_reader = tape_reader
        self.microstructure_analyzer = microstructure_analyzer
        self.signal_history = []
    
    def generate_signals(self) -> List[Dict]:
        """Generar seÃ±ales de trading basadas en microestructura"""
        
        signals = []
        
        # Obtener anÃ¡lisis actuales
        flow_analysis = self.tape_reader.analyze_order_flow(5)
        patterns = self.tape_reader.detect_tape_patterns()
        pressure = self.tape_reader.calculate_buying_selling_pressure()
        microstructure_patterns = self.microstructure_analyzer.detect_order_flow_patterns()
        
        # SeÃ±al 1: Breakout confirmation
        if self._detect_breakout_confirmation(patterns, pressure, microstructure_patterns):
            signals.append({
                'type': 'breakout_confirmation',
                'direction': 'long' if pressure.get('buy_pressure_ratio', 0.5) > 0.6 else 'short',
                'strength': 0.8,
                'reasoning': 'Strong order flow + microstructure confirmation',
                'supporting_data': {
                    'patterns': patterns,
                    'pressure': pressure,
                    'microstructure': microstructure_patterns
                }
            })
        
        # SeÃ±al 2: Institutional flow
        if self._detect_institutional_flow(flow_analysis, patterns):
            signals.append({
                'type': 'institutional_flow',
                'direction': 'long' if flow_analysis.get('buy_sell_ratio', 1) > 1.2 else 'short',
                'strength': 0.7,
                'reasoning': 'Institutional size trading detected',
                'supporting_data': {
                    'flow_analysis': flow_analysis,
                    'patterns': patterns
                }
            })
        
        # SeÃ±al 3: Liquidity provision opportunity
        if self._detect_liquidity_opportunity(microstructure_patterns):
            signals.append({
                'type': 'liquidity_provision',
                'direction': 'neutral',
                'strength': 0.6,
                'reasoning': 'Market making opportunity detected',
                'supporting_data': {
                    'microstructure': microstructure_patterns
                }
            })
        
        # SeÃ±al 4: Momentum continuation
        if self._detect_momentum_continuation(patterns, pressure):
            direction = 'long' if patterns.get('upward_momentum') else 'short'
            signals.append({
                'type': 'momentum_continuation',
                'direction': direction,
                'strength': 0.9,
                'reasoning': 'Strong momentum with order flow confirmation',
                'supporting_data': {
                    'patterns': patterns,
                    'pressure': pressure
                }
            })
        
        # Guardar historial
        for signal in signals:
            signal['timestamp'] = datetime.now()
            self.signal_history.append(signal)
        
        return signals
    
    def _detect_breakout_confirmation(self, patterns: Dict, pressure: Dict, 
                                   microstructure_patterns: Dict) -> bool:
        """Detectar confirmaciÃ³n de breakout"""
        
        # Condiciones para breakout confirmation
        conditions = [
            pressure.get('buy_pressure_ratio', 0.5) > 0.65 or pressure.get('buy_pressure_ratio', 0.5) < 0.35,  # PresiÃ³n direccional
            patterns.get('institutional_activity', False),  # Actividad institucional
            not microstructure_patterns.get('high_volatility', False),  # No alta volatilidad
            microstructure_patterns.get('depth_depletion', False)  # DepleciÃ³n de liquidez
        ]
        
        return sum(conditions) >= 3
    
    def _detect_institutional_flow(self, flow_analysis: Dict, patterns: Dict) -> bool:
        """Detectar flujo institucional"""
        
        # Condiciones para flujo institucional
        large_trade_pct = flow_analysis.get('large_trade_volume_pct', 0)
        avg_trade_size = flow_analysis.get('avg_trade_size', 0)
        
        return (
            large_trade_pct > 0.25 and  # >25% volumen en trades grandes
            avg_trade_size > 500 and   # TamaÃ±o promedio grande
            patterns.get('institutional_activity', False)  # PatrÃ³n institucional
        )
    
    def _detect_liquidity_opportunity(self, microstructure_patterns: Dict) -> bool:
        """Detectar oportunidad de provisiÃ³n de liquidez"""
        
        return (
            microstructure_patterns.get('spread_widening', False) and
            not microstructure_patterns.get('high_volatility', False)
        )
    
    def _detect_momentum_continuation(self, patterns: Dict, pressure: Dict) -> bool:
        """Detectar continuaciÃ³n de momentum"""
        
        has_momentum = patterns.get('upward_momentum', False) or patterns.get('downward_momentum', False)
        consistent_pressure = (
            pressure.get('buy_pressure_ratio', 0.5) > 0.7 or 
            pressure.get('buy_pressure_ratio', 0.5) < 0.3
        )
        
        return has_momentum and consistent_pressure

# Demo de integraciÃ³n completa
def demo_microstructure_integration():
    """Demo de integraciÃ³n completa de microestructura"""
    
    # Inicializar componentes
    tape_reader = TapeReader()
    microstructure_analyzer = MarketMicrostructureAnalyzer()
    signal_generator = MicrostructureSignalGenerator(tape_reader, microstructure_analyzer)
    
    print("ðŸ”„ Simulando trading session con microestructura...")
    
    # Simular sesiÃ³n de trading
    base_price = 100.0
    current_time = datetime.now()
    
    # Generar order books y trades sintÃ©ticos
    for i in range(50):
        # Order book
        spread = 0.01 + np.random.exponential(0.005)
        bids = [OrderBookLevel(base_price - spread/2 - j*0.01, np.random.randint(100, 1000)) 
                for j in range(10)]
        asks = [OrderBookLevel(base_price + spread/2 + j*0.01, np.random.randint(100, 1000)) 
                for j in range(10)]
        
        order_book = OrderBook("AAPL", current_time + timedelta(seconds=i*30), bids, asks)
        microstructure_analyzer.add_order_book(order_book)
        
        # Trades
        for j in range(np.random.randint(1, 4)):
            trade_type = np.random.choice([TradeType.BUY_MARKET, TradeType.SELL_MARKET])
            aggressor = 'buy' if trade_type == TradeType.BUY_MARKET else 'sell'
            
            # Simular diferentes fases
            if i < 15:  # AcumulaciÃ³n
                size = np.random.choice([500, 1000, 2000], p=[0.6, 0.3, 0.1])
                aggressor = 'buy'
            elif i < 35:  # Breakout
                size = np.random.choice([200, 500, 1000], p=[0.4, 0.4, 0.2])
                base_price += np.random.normal(0.05, 0.02)  # Tendencia alcista
            else:  # DistribuciÃ³n
                size = np.random.choice([300, 800, 1500], p=[0.5, 0.3, 0.2])
                aggressor = 'sell'
            
            trade = Trade(
                symbol="AAPL",
                timestamp=current_time + timedelta(seconds=i*30 + j*10),
                price=round(base_price + np.random.normal(0, 0.01), 2),
                size=size,
                trade_type=trade_type,
                aggressor_side=aggressor
            )
            
            tape_reader.add_trade(trade)
    
    # Generar seÃ±ales
    signals = signal_generator.generate_signals()
    
    print(f"\nðŸ“ˆ SeÃ±ales generadas: {len(signals)}")
    for signal in signals:
        print(f"  ðŸŽ¯ {signal['type']}: {signal['direction']} (fuerza: {signal['strength']:.1f})")
        print(f"     RazÃ³n: {signal['reasoning']}")
    
    # Mostrar mÃ©tricas finales
    flow_analysis = tape_reader.analyze_order_flow(10)
    patterns = tape_reader.detect_tape_patterns()
    
    print(f"\nðŸ“Š Resumen final:")
    print(f"Buy/Sell ratio: {flow_analysis.get('buy_sell_ratio', 0):.2f}")
    print(f"Trades grandes: {flow_analysis.get('large_trade_volume_pct', 0):.1%}")
    print(f"Patrones: {[p for p, detected in patterns.items() if detected]}")

if __name__ == "__main__":
    demo_microstructure_integration()
```

Este sistema de market microstructure y tape reading moderno proporciona herramientas avanzadas para entender el flujo de Ã³rdenes y detectar oportunidades de trading basadas en la estructura interna del mercado.